package com.luxoft.fabric;

import com.google.protobuf.Empty;
import com.google.protobuf.Message;
import com.luxoft.fabric.ordering.FabricHelpers;
import com.luxoft.fabric.ordering.FabricQueryException;
import org.hyperledger.fabric.sdk.*;
import org.hyperledger.fabric.sdk.exception.InvalidArgumentException;
import org.hyperledger.fabric.sdk.exception.ProposalException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.lang.reflect.Method;
import java.util.*;
import java.util.concurrent.*;
import java.util.regex.Pattern;

/**
 * Event tracking with ordering and delivery guaranties.
 * <ol>
 * <li>Waits for block (K) to appear using regular fabric streams (or eventHub)</li>
 *
 * <li>Delays event notifications until the enableEventsDelivery() is called</li>
 *
 * <li>if this block is the next block in sequence performs processing asap</li>
 *
 * <li>if this block is out of order, delays for some time, waiting for the previous
 * blocks in range [HEAD..K-1] to appear</li>
 *
 * <li>when delay is over, downloads HEAD block to process</li>
 *
 * <li>When initial delay is over, process blocks in range (HEAD..TAIL) without
 * delays. Here TAIL is the most recent known block in channel.</li>
 *
 * <li>If it receives filtered blocks (HPF-1.1 feature), events are checked,
 * and if there are some events of interest necessary and their payload type
 * is not Void or Empty, full block is fetched to get event payload.</li>
 *
 * <li>Events are notified one by one, in order. Each event listener returns
 * CompletableFuture, and the next event would be notified as soon as the
 * previous' CompletableFuture is completed.
 * Note that this is done in order to enforce strict event ordering,
 * so that events could be emitted using target masks, not exact target
 * names only.
 * <br>Alternatively we can use dependencies, generated by application code,
 * however it seems to add unnecessary complexity.</li>
 *
 * <li>Channels are independent of each other, event listeners are shared among
 * them</li>
 *
 * <li>Events handlers registered with {@link com.google.protobuf.Message}-derived
 * argument type</li>
 *
 * <li> {@link OrderingEventTracker} use {@link Persister} class to persist block
 * processing state </li>
 * </ol>
 */
public class OrderingEventTracker implements EventTracker {

    @FunctionalInterface
    public interface EventListener<T> {
        CompletableFuture onEvent(ChaincodeEvent chaincodeEvent, T eventData);
    }

    private static class EventListenerInfo {
        final Pattern chaincodePattern;
        final Pattern eventNamePattern;
        final Class paramClass;
        final EventListener listener;

        EventListenerInfo(Pattern chaincodePattern,
                          Pattern eventNamePattern,
                          Class paramClass,
                          EventListener listener) {
            this.chaincodePattern = chaincodePattern;
            this.eventNamePattern = eventNamePattern;
            this.paramClass = paramClass;
            this.listener = listener;
        }
    }

    private static final Logger logger = LoggerFactory.getLogger(OrderingEventTracker.class);

    enum FetchPolicy {
        SLEEP, DELAY, IMMEDIATE, ERROR
    }

    private ScheduledExecutorService executorService = Executors.newScheduledThreadPool(1);
    private final Persister persister;
    private CompletableFuture enableEventsDelivery = new CompletableFuture();
    private Map<Channel, ChannelTracker> channelStateMap = new HashMap<>();
    private final List<EventListenerInfo> eventsWaiting = new CopyOnWriteArrayList<>();
    private CountDownLatch initialization = new CountDownLatch(1);

    // TODO: when startblock is too far in the past, should skip the gap?
    // TODO: when startBlock is in the future (due to backup restore), revert state?

    public interface BlockData {
        String getContentType();

        int getPriority();

        long getBlockNumber();

        Iterator<ChaincodeEvent> getBlockEvents();

        boolean isFilteredBlock();

        BlockInfo getBlockInfo();

        // fetch control
        boolean isComplete();

        void fetchData() throws FabricQueryException;
    }

    private class BlockInfoWrapper implements BlockData {
        private BlockInfo blockInfo;
        private final Channel channel;
        private final long blockNumber;

        private BlockInfoWrapper(BlockInfo blockInfo) {
            this.blockInfo = blockInfo;
            this.blockNumber = blockInfo.getBlockNumber();
            this.channel = null;
        }

        private BlockInfoWrapper(Channel channel, long blockNumber) {
            this.blockInfo = null;
            this.channel = channel;
            this.blockNumber = blockNumber;
        }

        @Override
        public String getContentType() {
            if (blockInfo == null)
                return "incomplete";
            else if (blockInfo.isFiltered())
                return "filtered";
            else
                return "full";
        }

        @Override
        public int getPriority() {
            if (blockInfo == null)
                return 0;
            else if (blockInfo.isFiltered())
                return 1;
            else
                return 2;
        }

        @Override
        public long getBlockNumber() {
            return blockNumber;
        }

        @Override
        public boolean isFilteredBlock() {
            return blockInfo != null && blockInfo.isFiltered();
        }

        @Override
        public boolean isComplete() {
            return blockInfo != null;
        }

        @Override
        public void fetchData() throws FabricQueryException {
            if (blockInfo == null)
                blockInfo = FabricQueryException.withGuard(()->channel.queryBlockByNumber(blockNumber));
        }

        @Override
        public BlockInfo getBlockInfo() {
            return blockInfo;
        }

        @Override
        public Iterator<ChaincodeEvent> getBlockEvents() {
            return FabricHelpers.getBlockEvents(blockInfo);
        }
    }

    private class EventListWrapper implements BlockData {
        private final long blockNumber;
        private boolean isComplete = false;
        private final LinkedHashMap<String, List<ChaincodeEvent>> txList;
        private final FabricQueryException.Consumer<EventListWrapper> processor;

        private EventListWrapper(long blockNumber,
                                 LinkedHashMap<String, List<ChaincodeEvent>> txList,
                                 FabricQueryException.Consumer<EventListWrapper> processor) {
            this.blockNumber = blockNumber;
            this.txList = txList;
            this.processor = processor;
        }

        @Override
        public String getContentType() {
            return "event list";
        }

        @Override
        public int getPriority() {
            return 3;
        }

        @Override
        public long getBlockNumber() {
            return blockNumber;
        }

        @Override
        public boolean isFilteredBlock() {
            return false;
        }

        @Override
        public boolean isComplete() {
            return this.isComplete;
        }

        @Override
        public void fetchData() throws FabricQueryException {
            processor.apply(this);
        }

        @Override
        public BlockInfo getBlockInfo() {
            return null;
        }

        @Override
        public Iterator<ChaincodeEvent> getBlockEvents() {
            return new Iterator<ChaincodeEvent>() {
                boolean hasNext = false;
                ChaincodeEvent next = null;

                final Iterator<List<ChaincodeEvent>> txIterator = txList.values().iterator();
                Iterator<ChaincodeEvent> eventIterator = Collections.emptyIterator();

                @Override
                public boolean hasNext() {
                    if (hasNext)
                        return true;

                    while (true) {
                        if (eventIterator.hasNext()) {
                            hasNext = true;
                            next = eventIterator.next();
                            return true;
                        }
                        if (txIterator.hasNext()) {
                            final List<ChaincodeEvent> nextTx = txIterator.next();
                            eventIterator = nextTx.iterator();
                        } else
                            return false;
                    }

                }

                @Override
                public ChaincodeEvent next() {
                    if (hasNext()) {
                        hasNext = false;
                        return next;
                    }
                    throw new NoSuchElementException();
                }

                @Override
                public void remove() {
                    eventIterator.remove();
                }
            };
        }

        public void setComplete() {
            this.isComplete = true;
        }
    }

    private class ChannelTracker {
        /* Block Number, which is next to process */
        private long nextBlockNumber = Long.MAX_VALUE;
        private final long startBlock;
        private long refetchBlockMillis = TimeUnit.SECONDS.toMillis(5);
        private long errorBlockMillis = TimeUnit.SECONDS.toMillis(10);
        private Map<Long, BlockData> blockInfoMap = new HashMap<>();
        private final Channel channel;
        private final String channelName;
        private FetchPolicy fetchPolicy = FetchPolicy.SLEEP;

        private ChannelTracker(Channel channel) throws InvalidArgumentException {
            this.channel = channel;
            this.channelName = channel.getName();
            if (persister != null)
                startBlock = persister.getStartBlock(channelName);
            else
                startBlock = Long.MAX_VALUE;

            if (startBlock > 0 && startBlock < Long.MAX_VALUE)
                nextBlockNumber = startBlock;

            channel.registerBlockListener(this::addBlock);
        }

        private synchronized void connectChannel() throws InvalidArgumentException, ProposalException {
            final BlockchainInfo blockchainInfo = channel.queryBlockchainInfo();
            long knownHeight = blockchainInfo.getHeight();
            long maxAvailBlockNumber = (knownHeight > 0) ? knownHeight : 1;

            if (nextBlockNumber > maxAvailBlockNumber) {
                nextBlockNumber = maxAvailBlockNumber;
                if (startBlock != nextBlockNumber)
                    saveStartBlock(nextBlockNumber);
            }

            if (nextBlockNumber != maxAvailBlockNumber)
                blockInfoMap.put(maxAvailBlockNumber, new BlockInfoWrapper(channel, maxAvailBlockNumber));

            initialization.countDown();
            scheduleNextBlockFetching();
        }

        public void addBlock(BlockInfo blockInfo) {
            addBlockData(new BlockInfoWrapper(blockInfo));
        }

        public synchronized void addBlockData(BlockData blockData) {
            while (true) {
                try {
                    initialization.await();
                    break;
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }

            final long expectingBlockNumber = nextBlockNumber;
            final long newBlockNumber = blockData.getBlockNumber();
            if (newBlockNumber < expectingBlockNumber)
                return;

            logger.info("Got block {}. Content={}", newBlockNumber, blockData.getContentType());
            boolean isHEAD = newBlockNumber == expectingBlockNumber;
            boolean needFetching = blockInfoMap.isEmpty() && newBlockNumber > expectingBlockNumber;

            blockInfoMap.compute(newBlockNumber, (k, v) ->
                    v == null || v.getPriority() < blockData.getPriority() ? blockData : v);

            if (needFetching)
                scheduleNextBlockFetching();
            else if (isHEAD)
                processNextBlock();
        }

        private void setFetchPolicyLk(FetchPolicy newFetchPolicy) {
            if (this.fetchPolicy != newFetchPolicy) {
                this.fetchPolicy = newFetchPolicy;
                logger.debug("FETCH POLICY: {}", fetchPolicy);
            }
        }

        private synchronized void executeAction(FabricQueryException.Runnable action) {
            if (blockInfoMap.isEmpty()) {
                setFetchPolicyLk(FetchPolicy.SLEEP);
                return;
            }

            setFetchPolicyLk(FetchPolicy.IMMEDIATE);
            try {
                action.run();
            } catch (FabricQueryException e) {
                // turn to error handling
                logger.warn("Exception while doing network action, sleep for awhile");
                setFetchPolicyLk(FetchPolicy.ERROR);
                scheduleAction(action);
            }
        }

        private synchronized void scheduleAction(FabricQueryException.Runnable action) {
            if (fetchPolicy == FetchPolicy.IMMEDIATE && blockInfoMap.isEmpty()) {
                setFetchPolicyLk(FetchPolicy.SLEEP);
                return;
            }

            switch (fetchPolicy) {
                case ERROR:
                    setFetchPolicyLk(FetchPolicy.DELAY);
                    executorService.schedule(()->executeAction(action), errorBlockMillis, TimeUnit.MILLISECONDS);
                    break;

                case SLEEP:
                    setFetchPolicyLk(FetchPolicy.DELAY);
                    executorService.schedule(()->executeAction(action), refetchBlockMillis, TimeUnit.MILLISECONDS);
                    break;

                case DELAY:
                    break;

                case IMMEDIATE:
                    executorService.submit(()->executeAction(action));
                    break;
            }
        }

        private synchronized void scheduleNextBlockFetching() {
            scheduleAction(()-> fetchBlock(nextBlockNumber));
        }

        private synchronized void processNextBlock() {
            BlockData blockData = blockInfoMap.get(nextBlockNumber);

            if (blockData == null) {
                scheduleNextBlockFetching();
            } else if (blockData.isFilteredBlock()) {
                blockData = transformFilteredBlock(blockData.getBlockInfo());
                blockInfoMap.put(nextBlockNumber, blockData);
            }

            if (blockData == null || !blockData.isComplete()) {
                scheduleNextBlockFetching();
            }

            // process full or event block
            if (blockData != null && blockData.isComplete())
                processBlock(blockData);
        }

        private void saveStartBlock(long blockNumber) {
            try {
                if (persister != null)
                    persister.setStartBlock(channelName, blockNumber);
            } catch (Exception e) {
                logger.warn("persisting block failed: {}", blockNumber);
            }
        }

        private synchronized void blockCompleted(long blockNumber) {

            if (blockNumber != nextBlockNumber)
                throw new InternalError(String.format("Invalid block number: %s, expect %s", blockNumber, nextBlockNumber));

            nextBlockNumber++;
            logger.debug("Advance to block {}", nextBlockNumber);

            saveStartBlock(nextBlockNumber);
            blockInfoMap.remove(nextBlockNumber - 1);

            processNextBlock();
        }

        private synchronized void processBlock(BlockData blockInfo) {
            CompletableFuture blockProcessor;

            if (enableEventsDelivery != null) {
                if (!enableEventsDelivery.isDone())
                    logger.info("Events delivery is not enabled, postpone block processing");
                blockProcessor = enableEventsDelivery;
            } else
                blockProcessor = CompletableFuture.completedFuture(null);

            final long blockNumber = blockInfo.getBlockNumber();

            final Iterator<ChaincodeEvent> eventIterator = blockInfo.getBlockEvents();
            while (eventIterator.hasNext()) {
                ChaincodeEvent event = eventIterator.next();

                for (EventListenerInfo listenerInfo : eventsWaiting) {
                    final String chaincodeId = event.getChaincodeId();
                    final String eventName = event.getEventName();
                    if (listenerInfo.chaincodePattern.matcher(chaincodeId).matches()
                            && listenerInfo.eventNamePattern.matcher(eventName).matches()) {

                        try {
                            final Method newBuilder = listenerInfo.paramClass.getMethod("newBuilder");
                            final Message.Builder builder = (Message.Builder) newBuilder.invoke(null);
                            final Message message;

                            if (Empty.class.isAssignableFrom(listenerInfo.paramClass))
                                message = Empty.getDefaultInstance();
                            else if (Void.class.isAssignableFrom(listenerInfo.paramClass))
                                message = null;
                            else
                                message = builder.mergeFrom(event.getPayload()).build();

                            blockProcessor = blockProcessor
                                    .thenCompose((r) -> {
                                        logger.info("Begin event handling(block={}, chaincode={}, name={}, data={}, txid={})", blockNumber, chaincodeId, eventName, message, event.getTxId());
                                        return listenerInfo.listener.onEvent(event, message);
                                    })
                                    .handle((r, t) -> {
                                        if (t != null)
                                            logger.warn("Event handling failed(block={}, chaincode={}, name={}, data={}, txid={})", blockNumber, chaincodeId, eventName, message, event.getTxId(), t);
                                        else
                                            logger.info("Event handling succeeded (block={}, chaincode={}, name={}, data={}, txid={}) -> ({})", blockNumber, chaincodeId, eventName, message, event.getTxId(), r);
                                        return null;
                                    });

                        } catch (Exception e) {
                            logger.warn("Prepare Event Handling failed(block={}, chaincode={}, name={}, txid={}): ", blockNumber, chaincodeId, eventName, event.getTxId(), e);
                        }
                    }
                }
            }

            blockProcessor.handle((r, t) -> {
                // go to process next block
                blockCompleted(blockNumber);
                return null;
            });

        }

        private void fetchBlock(long blockNumber) throws FabricQueryException {
            final BlockData blockData;

            synchronized (this) {
                if (blockNumber != nextBlockNumber)
                    return;

                blockData = blockInfoMap.get(blockNumber);
                if (blockData != null && blockData.isComplete())
                    return;
            }

            logger.info("Fetch block {}", blockNumber);

            blockData.fetchData();
            if (blockData.isComplete())
                addBlockData(blockData);
        }

        private boolean filterTransactionEvents(List<ChaincodeEvent> transactionEvents, boolean isFilteredData) {
            boolean needFetching = false;

            for (Iterator<ChaincodeEvent> iterator = transactionEvents.iterator(); iterator.hasNext(); ) {
                ChaincodeEvent chaincodeEvent = iterator.next();
                for (EventListenerInfo e : eventsWaiting) {
                    final String chaincodeId = chaincodeEvent.getChaincodeId();
                    final String eventName = chaincodeEvent.getEventName();
                    if (e.chaincodePattern.matcher(chaincodeId).matches()
                            && e.eventNamePattern.matcher(eventName).matches()) {
                        if (!Empty.class.isAssignableFrom(e.paramClass)
                                && e.paramClass != Void.class) {
                            needFetching = isFilteredData;
                        }
                    } else {
                        iterator.remove();
                    }
                }
            }
            return needFetching;
        }

        private void fetchFilteredBlockEvents(EventListWrapper blockData) throws FabricQueryException {
            final LinkedHashMap<String, List<ChaincodeEvent>> txList = blockData.txList;
            for (Iterator<Map.Entry<String, List<ChaincodeEvent>>> iterator = txList.entrySet().iterator(); iterator.hasNext(); ) {
                Map.Entry<String, List<ChaincodeEvent>> entry = iterator.next();
                if (entry.getValue() == null) {
                    try {
                        final List<ChaincodeEvent> chaincodeEvents = TxUtil.queryEventsByTransactionID(channel, entry.getKey());
                        filterTransactionEvents(chaincodeEvents, false);
                        if (chaincodeEvents.isEmpty())
                            iterator.remove();
                        else
                            entry.setValue(chaincodeEvents);
                    } catch (FabricQueryException e) {
                        logger.warn("Unable to query events, repeat", e);
                        throw e;
                    } catch (Exception ex) {
                        logger.warn("Unable to parse events, ignore", ex);
                        entry.setValue(Collections.EMPTY_LIST);
                    }
                }
            }

            blockData.setComplete();
        }

        private BlockData transformFilteredBlock(BlockInfo filteredBlock) {
            final Iterator<BlockInfo.TransactionEnvelopeInfo> txIterator = FabricHelpers.getBlockTransactions(filteredBlock);
            final LinkedHashMap<String, List<ChaincodeEvent>> txList = new LinkedHashMap<>();
            boolean needsFetching = false;

            while (txIterator.hasNext()) {
                final BlockInfo.TransactionEnvelopeInfo transactionEnvelopeInfo = txIterator.next();
                List<ChaincodeEvent> transactionEvents = FabricHelpers.getTransactionEvents(transactionEnvelopeInfo);

                if (filterTransactionEvents(transactionEvents, true)) {
                    txList.put(transactionEnvelopeInfo.getTransactionID(), null);
                    needsFetching = true;
                } else if (!transactionEvents.isEmpty()) {
                    txList.put(transactionEnvelopeInfo.getTransactionID(), transactionEvents);
                }
            }

            final EventListWrapper blockData = new EventListWrapper(filteredBlock.getBlockNumber(), txList, this::fetchFilteredBlockEvents);
            if (!needsFetching)
                blockData.setComplete();
            return blockData;
        }
    }

    public OrderingEventTracker(Persister persister) {
        this.persister = persister;
    }

    @Override
    public void configureChannel(Channel channel) throws Exception {
        if (!channelStateMap.containsKey(channel)) {
            final ChannelTracker channelTracker = new ChannelTracker(channel);
            channelStateMap.put(channel, channelTracker);
        }
    }

    @Override
    public void connectChannel(Channel channel) throws Exception {
        channelStateMap.get(channel).connectChannel();
    }

    @Override
    public long getStartBlock(Channel channel) {
        return channelStateMap.get(channel).startBlock;
    }

    @Override
    public boolean useFilteredBlocks(Channel channel) {
        return true;
    }

    public <T extends Message> void addEventListener(String chaincodeName, String eventName, Class<T> parameterClass, EventListener<T> listener) {
        final EventListenerInfo eventListenerInfo = new EventListenerInfo(
                Pattern.compile(chaincodeName),
                Pattern.compile(eventName),
                parameterClass,
                listener);
        eventsWaiting.add(eventListenerInfo);
    }

    public synchronized void enableEventsDelivery() {
        if (enableEventsDelivery != null) {
            logger.info("Enable events delivery");
            enableEventsDelivery.complete(null);
            enableEventsDelivery = null;
        }
    }
}

