package com.luxoft.fabric;

import com.google.protobuf.Empty;
import com.google.protobuf.Message;
import org.hyperledger.fabric.sdk.*;
import org.hyperledger.fabric.sdk.exception.InvalidArgumentException;
import org.hyperledger.fabric.sdk.exception.ProposalException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.lang.reflect.Method;
import java.util.*;
import java.util.concurrent.*;
import java.util.regex.Pattern;

/**
 * Event tracking with ordering and delivery guaranties.
 * <ol>
 * <li>Waits for block (K) to appear using regular fabric streams (or eventHub)</li>
 *
 * <li>Delays event notifications until the enableEventsDelivery() is called</li>
 *
 * <li>if this block is the next block in sequence performs processing asap</li>
 *
 * <li>if this block is out of order, delays for some time, waiting for the previous
 * blocks in range [HEAD..K-1] to appear</li>
 *
 * <li>when delay is over, downloads HEAD block to process</li>
 *
 * <li>When initial delay is over, process blocks in range (HEAD..TAIL) without
 * delays. Here TAIL is the most recent known block in channel.</li>
 *
 * <li>If it receives filtered blocks (HPF-1.1 feature), events are checked,
 * and if there are some events of interest necessary and their payload type
 * is not Void or Empty, full block is fetched to get event payload.</li>
 *
 * <li>Events are notified one by one, in order. Each event listener returns
 * CompletableFuture, and the next event would be notified as soon as the
 * previous' CompletableFuture is completed.
 * Note that this is done in order to enforce strict event ordering,
 * so that events could be emitted using target masks, not exact target
 * names only.
 * <br>Alternatively we can use dependencies, generated by application code,
 * however it seems to add unnecessary complexity.</li>
 *
 * <li>Channels are independent of each other, event listeners are shared among
 * them</li>
 *
 * <li>Events handlers registered with {@link com.google.protobuf.Message}-derived
 * argument type</li>
 *
 * <li> {@link OrderingEventTracker} use {@link Persister} class to persist block
 * processing state </li>
 * </ol>
 */
public class OrderingEventTracker implements EventTracker {

    @FunctionalInterface
    public interface EventListener<T> {
        CompletableFuture onEvent(ChaincodeEvent chaincodeEvent, T eventData);
    }

    private static class EventListenerInfo {
        final Pattern chaincodePattern;
        final Pattern eventNamePattern;
        final Class paramClass;
        final EventListener listener;

        EventListenerInfo(Pattern chaincodePattern,
                          Pattern eventNamePattern,
                          Class paramClass,
                          EventListener listener) {
            this.chaincodePattern = chaincodePattern;
            this.eventNamePattern = eventNamePattern;
            this.paramClass = paramClass;
            this.listener = listener;
        }
    }

    private static final Logger logger = LoggerFactory.getLogger(OrderingEventTracker.class);

    enum FetchPolicy {
        SLEEP, DELAY, IMMEDIATE
    }

    private ScheduledExecutorService executorService = Executors.newScheduledThreadPool(1);
    private final Persister persister;
    private CompletableFuture enableEventsDelivery = new CompletableFuture();
    private Map<Channel, ChannelTracker> channelStateMap = new HashMap<>();
    private final List<EventListenerInfo> eventsWaiting = new CopyOnWriteArrayList<>();
    private CountDownLatch initialization = new CountDownLatch(1);

    // TODO: when startblock is too far in the past, should skip the gap?
    // TODO: when startBlock is in the future (due to backup restore), revert state?

    private class ChannelTracker {
        /* Block Number, which is next to process */
        private long nextBlockNumber = Long.MAX_VALUE;
        private final long startBlock;
        private int refetchBlockMillis = 5000;
        private Map<Long, BlockInfo> blockInfoMap = new HashMap<>();
        private Set<Long> fetchingBlocks = new HashSet<>();
        private final Channel channel;
        private final String channelName;
        private FetchPolicy fetchPolicy = FetchPolicy.SLEEP;

        private ChannelTracker(Channel channel) throws InvalidArgumentException {
            this.channel = channel;
            this.channelName = channel.getName();
            if (persister != null)
                startBlock = persister.getStartBlock(channelName);
            else
                startBlock = Long.MAX_VALUE;

            if (startBlock > 0 && startBlock < Long.MAX_VALUE)
                nextBlockNumber = startBlock;

            channel.registerBlockListener(this::addBlock);
        }

        private synchronized void connectChannel() throws InvalidArgumentException, ProposalException {
            final BlockchainInfo blockchainInfo = channel.queryBlockchainInfo();
            long knownHeight = blockchainInfo.getHeight();
            long maxAvailBlockNumber = (knownHeight > 0) ? knownHeight : 1;

            if (nextBlockNumber > maxAvailBlockNumber) {
                nextBlockNumber = maxAvailBlockNumber;
                if (startBlock != nextBlockNumber)
                    saveStartBlock(nextBlockNumber);
            }

            if (nextBlockNumber != maxAvailBlockNumber)
                blockInfoMap.put(maxAvailBlockNumber, null);

            initialization.countDown();
            scheduleBlockFetching();
        }

        public synchronized void addBlock(BlockInfo blockInfo) {
            while (true) {
                try {
                    initialization.await();
                    break;
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }

            final long expectingBlockNumber = nextBlockNumber;
            final long newBlockNumber = blockInfo.getBlockNumber();
            if (newBlockNumber < expectingBlockNumber)
                return;

            logger.info("Got block {}. Content={}", newBlockNumber, blockInfo.isFiltered() ? "filtered" : "full");
            boolean isHEAD = newBlockNumber == expectingBlockNumber;
            boolean needFetching = blockInfoMap.isEmpty() && newBlockNumber > expectingBlockNumber;

            blockInfoMap.compute(newBlockNumber, (k, v) -> v == null || v.isFiltered() ? blockInfo : v);

            if (needFetching)
                scheduleBlockFetching();
            else if (isHEAD)
                processHeadingBlock();
        }

        private void setFetchPolicyLk(FetchPolicy newFetchPolicy) {
            if (this.fetchPolicy != newFetchPolicy) {
                this.fetchPolicy = newFetchPolicy;
                logger.debug("FETCH POLICY: {}", fetchPolicy);
            }
        }

        private synchronized void scheduleBlockFetching() {
            if (blockInfoMap.isEmpty()) {
                setFetchPolicyLk(FetchPolicy.SLEEP);
                return;
            }

            switch (fetchPolicy) {
                case SLEEP:
                    setFetchPolicyLk(FetchPolicy.DELAY);
                    executorService.schedule(this::fetchHeadBlock, refetchBlockMillis, TimeUnit.MILLISECONDS);
                    break;

                case DELAY:
                    break;

                case IMMEDIATE:
                    executorService.submit(this::fetchHeadBlock);
                    break;
            }
        }

        private synchronized void fetchHeadBlock() {
            if (blockInfoMap.isEmpty()) {
                setFetchPolicyLk(FetchPolicy.SLEEP);
                return;
            }

            setFetchPolicyLk(FetchPolicy.IMMEDIATE);
            refetchBlock(nextBlockNumber);
        }

        private synchronized void processHeadingBlock() {
            final BlockInfo blockInfo = blockInfoMap.get(nextBlockNumber);
            final long blockNumber = blockInfo.getBlockNumber();
            if (blockInfo == null)
                refetchBlock(blockNumber);
            else if (blockInfo.isFiltered()) {
                if (needFullBlock(blockInfo)) {
                    /** @// TODO: this should delay just like {@link #scheduleBlockFetching()} */
                    logger.info("Need full block {}", blockNumber);
                    refetchBlock(blockNumber);
                } else {
                    blockCompleted(nextBlockNumber);
                }
                return;
            }

            // process full block
            handleBlock(blockInfo);
        }

        private void saveStartBlock(long blockNumber) {
            try {
                if (persister != null)
                    persister.setStartBlock(channelName, blockNumber);
            } catch (Exception e) {
                logger.warn("persisting block failed: {}", blockNumber);
            }
        }

        private synchronized void blockCompleted(long blockNumber) {

            if (blockNumber != nextBlockNumber)
                throw new InternalError(String.format("Invalid block number: %s, expect %s", blockNumber, nextBlockNumber));

            nextBlockNumber++;
            logger.debug("Advance to block {}", nextBlockNumber);

            saveStartBlock(nextBlockNumber);
            blockInfoMap.remove(nextBlockNumber - 1);

            final BlockInfo blockInfo = blockInfoMap.get(nextBlockNumber);
            if (blockInfo == null)
                scheduleBlockFetching();
            else
                handleBlock(blockInfo);
        }

        private synchronized void handleBlock(BlockInfo blockInfo) {
            CompletableFuture blockProcessor;

            if (enableEventsDelivery != null) {
                if (!enableEventsDelivery.isDone())
                    logger.info("Events delivery is not enabled, postpone block processing");
                blockProcessor = enableEventsDelivery;
            } else
                blockProcessor = CompletableFuture.completedFuture(null);

            final long blockNumber = blockInfo.getBlockNumber();

            final Iterator<ChaincodeEvent> eventIterator = getBlockEvents(blockInfo);
            while (eventIterator.hasNext()) {
                ChaincodeEvent event = eventIterator.next();

                for (EventListenerInfo listenerInfo : eventsWaiting) {
                    final String chaincodeId = event.getChaincodeId();
                    final String eventName = event.getEventName();
                    if (listenerInfo.chaincodePattern.matcher(chaincodeId).matches()
                            && listenerInfo.eventNamePattern.matcher(eventName).matches()) {

                        try {
                            final Method newBuilder = listenerInfo.paramClass.getMethod("newBuilder");
                            final Message.Builder builder = (Message.Builder) newBuilder.invoke(null);
                            final Message message;

                            if (Empty.class.isAssignableFrom(listenerInfo.paramClass))
                                message = Empty.getDefaultInstance();
                            else if (Void.class.isAssignableFrom(listenerInfo.paramClass))
                                message = null;
                            else
                                message = builder.mergeFrom(event.getPayload()).build();

                            blockProcessor = blockProcessor
                                    .thenCompose((r) -> {
                                        logger.info("Begin event handling(block={}, chaincode={}, name={}, data={}, txid={})", blockNumber, chaincodeId, eventName, message, event.getTxId());
                                        return listenerInfo.listener.onEvent(event, message);
                                    })
                                    .handle((r, t) -> {
                                        if (t != null)
                                            logger.warn("Event handling failed(block={}, chaincode={}, name={}, data={}, txid={})", blockNumber, chaincodeId, eventName, message, event.getTxId(), t);
                                        else
                                            logger.info("Event handling succeeded (block={}, chaincode={}, name={}, data={}, txid={}) -> ({})", blockNumber, chaincodeId, eventName, message, event.getTxId(), r);
                                        return null;
                                    });

                        } catch (Exception e) {
                            logger.warn("Prepare Event Handling failed(block={}, chaincode={}, name={}, txid={}): ", blockNumber, chaincodeId, eventName, event.getTxId(), e);
                        }
                    }
                }
            }

            blockProcessor.handle((r, t) -> {
                // go to process next block
                blockCompleted(blockNumber);
                return null;
            });

        }

        private boolean needFetching(long blockNumber, boolean refetch) {
            if (blockNumber < nextBlockNumber)
                return false;

            if (!blockInfoMap.containsKey(blockNumber))
                return true;
            else if (refetch) {
                final BlockInfo existingBlock = blockInfoMap.get(blockNumber);
                return existingBlock.isFiltered();
            } else
                return true;
        }

        private void doBlockFetching(long blockNumber, boolean refetch) {
            Object waiter = this;
            BlockInfo blockInfo = null;

            synchronized (waiter) {
                if (!needFetching(blockNumber, refetch)) {
                    fetchingBlocks.remove(blockNumber);
                    return;
                }
            }

            try {
                logger.info("Fetch block {}", blockNumber);
                blockInfo = channel.queryBlockByNumber(blockNumber);
            } catch (Exception e) {
                // retry attempt
                executorService.submit(() -> doBlockFetching(blockNumber, refetch));
                return;
            }

            synchronized (waiter) {
                fetchingBlocks.remove(blockNumber);
                if (needFetching(blockNumber, refetch))
                    addBlock(blockInfo);
            }
        }

        private void refetchBlock(long blockNumber) {
            Object waiter = this;

            synchronized (waiter) {
                if (blockNumber < nextBlockNumber)
                    return;

                final BlockInfo blockInfo = blockInfoMap.get(blockNumber);
                if (blockInfo != null && !blockInfo.isFiltered())
                    return;

                if (!fetchingBlocks.add(blockNumber))
                    return;
            }

            executorService.submit(() -> doBlockFetching(blockNumber, true));
        }

        private Iterator<ChaincodeEvent> getBlockEvents(BlockInfo blockInfo) {

            Iterator<ChaincodeEvent> iterator = new Iterator<ChaincodeEvent>() {
                final Iterator<BlockInfo.EnvelopeInfo> envelopeInfoIterator = blockInfo.getEnvelopeInfos().iterator();
                Iterator<BlockInfo.TransactionEnvelopeInfo.TransactionActionInfo> actionIterator = Collections.emptyIterator();

                boolean hasNext = false;
                ChaincodeEvent nextObject = null;

                private ChaincodeEvent nextObject() {
                    checkNextObject:
                    while (true) {
                        while (actionIterator.hasNext()) {
                            final BlockInfo.TransactionEnvelopeInfo.TransactionActionInfo actionInfo = actionIterator.next();

                            final ChaincodeEvent event = actionInfo.getEvent();
                            if (event != null)
                                return event;
                        }

                        while (envelopeInfoIterator.hasNext()) {
                            final BlockInfo.EnvelopeInfo envelopeInfo = envelopeInfoIterator.next();

                            if (envelopeInfo.isValid() && envelopeInfo instanceof BlockInfo.TransactionEnvelopeInfo) {
                                final BlockInfo.TransactionEnvelopeInfo transactionEnvelopeInfo = (BlockInfo.TransactionEnvelopeInfo) envelopeInfo;
                                actionIterator = transactionEnvelopeInfo.getTransactionActionInfos().iterator();
                                continue checkNextObject;
                            }
                        }
                        return null;
                    }
                }

                @Override
                public boolean hasNext() {
                    if (!hasNext) {
                        nextObject = nextObject();
                        hasNext = nextObject != null;
                    }

                    return hasNext;
                }

                @Override
                public ChaincodeEvent next() {
                    hasNext();
                    if (!hasNext)
                        throw new NoSuchElementException();
                    hasNext = false;
                    return nextObject;
                }
            };

            return iterator;
        }

        private boolean needFullBlock(BlockInfo blockInfo) {
            // check if we need full block
            final Iterator<ChaincodeEvent> eventIterator = getBlockEvents(blockInfo);
            while (eventIterator.hasNext()) {
                final ChaincodeEvent chaincodeEvent = eventIterator.next();
                for (EventListenerInfo e : eventsWaiting) {
                    final String chaincodeId = chaincodeEvent.getChaincodeId();
                    final String eventName = chaincodeEvent.getEventName();
                    if (e.chaincodePattern.matcher(chaincodeId).matches()
                            && e.eventNamePattern.matcher(eventName).matches()
                            && !Empty.class.isAssignableFrom(e.paramClass)
                            && e.paramClass != Void.class) {
                        return true;
                    }
                }
            }
            return false;
        }

    }

    public OrderingEventTracker(Persister persister) {
        this.persister = persister;
    }

    @Override
    public void configureChannel(Channel channel) throws Exception {
        if (!channelStateMap.containsKey(channel)) {
            final ChannelTracker channelTracker = new ChannelTracker(channel);
            channelStateMap.put(channel, channelTracker);
        }
    }

    @Override
    public void connectChannel(Channel channel) throws Exception {
        channelStateMap.get(channel).connectChannel();
    }

    @Override
    public long getStartBlock(Channel channel) {
        return channelStateMap.get(channel).startBlock;
    }

    @Override
    public boolean useFilteredBlocks(Channel channel) {
        return true;
    }

    public <T extends Message> void addEventListener(String chaincodeName, String eventName, Class<T> parameterClass, EventListener<T> listener) {
        final EventListenerInfo eventListenerInfo = new EventListenerInfo(
                Pattern.compile(chaincodeName),
                Pattern.compile(eventName),
                parameterClass,
                listener);
        eventsWaiting.add(eventListenerInfo);
    }

    public synchronized void enableEventsDelivery() {
        if (enableEventsDelivery != null) {
            logger.info("Enable events delivery");
            enableEventsDelivery.complete(null);
            enableEventsDelivery = null;
        }
    }
}
