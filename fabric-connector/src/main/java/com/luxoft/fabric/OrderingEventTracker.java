package com.luxoft.fabric;

import com.google.protobuf.Empty;
import com.google.protobuf.Message;
import com.luxoft.fabric.ordering.FabricQueryException;
import com.luxoft.fabric.utils.TxUtils;
import org.hyperledger.fabric.sdk.*;
import org.hyperledger.fabric.sdk.exception.InvalidArgumentException;
import org.hyperledger.fabric.sdk.exception.ProposalException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.lang.ref.WeakReference;
import java.lang.reflect.Method;
import java.util.*;
import java.util.concurrent.*;
import java.util.regex.Pattern;

/**
 * Event tracking with ordering and delivery guaranties.
 * <ol>
 * <li>Waits for block (K) to appear using regular fabric streams (or eventHub)</li>
 *
 * <li>Delays event notifications until the enableEventsDelivery() is called</li>
 *
 * <li>if this block is the next block in sequence performs processing asap</li>
 *
 * <li>if this block is out of order, delays for some time, waiting for the previous
 * blocks in range [HEAD..K-1] to appear</li>
 *
 * <li>when delay is over, downloads HEAD block to process</li>
 *
 * <li>When initial delay is over, process blocks in range (HEAD..TAIL) without
 * delays. Here TAIL is the most recent known block in channel.</li>
 *
 * <li>If it receives filtered blocks (HPF-1.1 feature), events are checked,
 * and if there are some events of interest necessary and their payload type
 * is not Void or Empty, full block is fetched to get event payload.</li>
 *
 * <li>Events are notified one by one, in order. Each event listener returns
 * CompletableFuture, and the next event would be notified as soon as the
 * previous' CompletableFuture is completed.
 * Note that this is done in order to enforce strict event ordering,
 * so that events could be emitted using target masks, not exact target
 * names only.
 * <br>Alternatively we can use dependencies, generated by application code,
 * however it seems to add unnecessary complexity.</li>
 *
 * <li>Channels are independent of each other, event listeners are shared among
 * them</li>
 *
 * <li>Events handlers registered with {@link com.google.protobuf.Message}-derived
 * argument type</li>
 *
 * <li> {@link OrderingEventTracker} use {@link Persister} class to persist block
 * processing state </li>
 * </ol>
 */
public class OrderingEventTracker implements EventTracker {

    public interface EventListener<T> {
        CompletableFuture<Boolean> filter(ChaincodeEvent chaincodeEvent);

        CompletableFuture onEvent(ChaincodeEvent chaincodeEvent, T eventData);
    }

    private static class EventListenerInfo {
        final Pattern chaincodePattern;
        final Pattern eventNamePattern;
        final Class paramClass;
        final EventListener listener;

        EventListenerInfo(Pattern chaincodePattern,
                          Pattern eventNamePattern,
                          Class paramClass,
                          EventListener listener) {
            this.chaincodePattern = chaincodePattern;
            this.eventNamePattern = eventNamePattern;
            this.paramClass = paramClass;
            this.listener = listener;
        }
    }

    private static final Logger logger = LoggerFactory.getLogger(OrderingEventTracker.class);

    enum FetchPolicy {
        SLEEP, DELAY, IMMEDIATE, ERROR
    }

    private ScheduledExecutorService executorService = Executors.newScheduledThreadPool(1);
    private final Persister persister;
    private CompletableFuture<Void> enableEventsDelivery = new CompletableFuture<>();
    private Map<Channel, ChannelTracker> channelStateMap = new HashMap<>();
    private final List<EventListenerInfo> eventsWaiting = new CopyOnWriteArrayList<>();
    private CountDownLatch initialization = new CountDownLatch(1);

    // TODO: when startblock is too far in the past, should skip the gap?
    // TODO: when startBlock is in the future (due to backup restore), revert state?

    class EventSubscription {
        final WeakReference<EventListenerInfo> listenerInfo;
        final String transactionId;
        final int eventIndex;
        final boolean needFetching;

        EventSubscription(EventListenerInfo listenerInfo, String transactionId, int eventIndex, boolean needFetching) {
            this.listenerInfo = new WeakReference<>(listenerInfo);
            this.transactionId = transactionId;
            this.eventIndex = eventIndex;
            this.needFetching = needFetching;
        }
    }

    class EventSubscriptionList {
        final List<EventSubscription> subscriptions = new CopyOnWriteArrayList<>();
        Boolean needsFetching = false;
    }

    public class BlockData {
        private BlockInfo blockInfo = null;
        private long blockNumber;
        private EventSubscriptionList eventSubscriptionList = null;
        private Map<String, List<ChaincodeEvent>> txList = new HashMap<>();
        private Set<String> fetchQueue = new HashSet<>();
        private CompletableFuture<Void> processing = null;

        BlockData(BlockInfo blockInfo) {
            this.blockInfo = blockInfo;
            this.blockNumber = blockInfo.getBlockNumber();
        }

        BlockData(long blockNumber) {
            this.blockNumber = blockNumber;
        }

        long getBlockNumber() {
            return blockNumber;
        }

        String getContentType() {
            if (blockInfo == null)
                return "incomplete";
            else if (blockInfo.isFiltered())
                return "filtered";
            else
                return "full";
        }

        int getPriority() {
            if (blockInfo == null)
                return 0;
            else if (blockInfo.isFiltered())
                return 1;
            else
                return 2;
        }
    }

    private class ChannelTracker {
        /* Block Number, which is next to process */
        private long nextBlockNumber = Long.MAX_VALUE;
        private final long startBlock;
        private long refetchBlockMillis = TimeUnit.SECONDS.toMillis(5);
        private long errorBlockMillis = TimeUnit.SECONDS.toMillis(10);
        private Map<Long, BlockData> blockInfoMap = new HashMap<>();
        private final Channel channel;
        private final String channelName;
        private FetchPolicy fetchPolicy = FetchPolicy.SLEEP;

        private ChannelTracker(Channel channel) throws InvalidArgumentException {
            this.channel = channel;
            this.channelName = channel.getName();
            if (persister != null)
                startBlock = persister.getStartBlock(channelName);
            else
                startBlock = Long.MAX_VALUE;

            if (startBlock > 0 && startBlock < Long.MAX_VALUE)
                nextBlockNumber = startBlock;

            channel.registerBlockListener(this::addBlock);
        }

        private synchronized void connectChannel() throws InvalidArgumentException, ProposalException {
            final BlockchainInfo blockchainInfo = channel.queryBlockchainInfo();
            long knownHeight = blockchainInfo.getHeight();
            long maxAvailBlockNumber = (knownHeight > 0) ? knownHeight : 1;

            if (nextBlockNumber > maxAvailBlockNumber) {
                nextBlockNumber = maxAvailBlockNumber;
                if (startBlock != nextBlockNumber)
                    saveStartBlock(nextBlockNumber);
            }

            if (nextBlockNumber != maxAvailBlockNumber)
                blockInfoMap.put(maxAvailBlockNumber, new BlockData(maxAvailBlockNumber));

            initialization.countDown();
            scheduleNextBlockFetching();
        }

        private void addBlock(BlockInfo blockInfo) {
            addBlockData(new BlockData(blockInfo));
        }

        private synchronized void addBlockData(BlockData blockData) {
            while (true) {
                try {
                    initialization.await();
                    break;
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }

            final long expectingBlockNumber = nextBlockNumber;
            final long newBlockNumber = blockData.getBlockNumber();
            if (newBlockNumber < expectingBlockNumber)
                return;

            logger.info("Got block {}. Content={}", newBlockNumber, blockData.getContentType());
            boolean isHEAD = newBlockNumber == expectingBlockNumber;
            boolean needFetching = blockInfoMap.isEmpty() && newBlockNumber > expectingBlockNumber;

            blockInfoMap.compute(newBlockNumber, (k, v) ->
                    v == null || v.getPriority() < blockData.getPriority() ? blockData : v);

            if (needFetching)
                scheduleNextBlockFetching();
            else if (isHEAD)
                processNextBlock();
        }

        private void setFetchPolicyLk(FetchPolicy newFetchPolicy) {
            if (this.fetchPolicy != newFetchPolicy) {
                this.fetchPolicy = newFetchPolicy;
                logger.debug("FETCH POLICY: {}", fetchPolicy);
            }
        }

        private synchronized void executeAction(FabricQueryException.Runnable action) {
            if (blockInfoMap.isEmpty()) {
                setFetchPolicyLk(FetchPolicy.SLEEP);
                return;
            }

            setFetchPolicyLk(FetchPolicy.IMMEDIATE);
            try {
                action.run();
            } catch (FabricQueryException e) {
                // turn to error handling
                logger.warn("Exception while doing network action, sleep for awhile");
                setFetchPolicyLk(FetchPolicy.ERROR);
                scheduleAction(action);
            }
        }

        private synchronized void scheduleAction(FabricQueryException.Runnable action) {
            if (fetchPolicy == FetchPolicy.IMMEDIATE && blockInfoMap.isEmpty()) {
                setFetchPolicyLk(FetchPolicy.SLEEP);
                return;
            }

            switch (fetchPolicy) {
                case ERROR:
                    setFetchPolicyLk(FetchPolicy.DELAY);
                    executorService.schedule(() -> executeAction(action), errorBlockMillis, TimeUnit.MILLISECONDS);
                    break;

                case SLEEP:
                    setFetchPolicyLk(FetchPolicy.DELAY);
                    executorService.schedule(() -> executeAction(action), refetchBlockMillis, TimeUnit.MILLISECONDS);
                    break;

                case DELAY:
                    break;

                case IMMEDIATE:
                    executorService.submit(() -> executeAction(action));
                    break;
            }
        }

        private synchronized void scheduleNextBlockFetching() {
            scheduleAction(() -> fetchBlock(nextBlockNumber));
        }

        private CompletableFuture<EventSubscriptionList> filterSubscriptions(BlockData blockData) {
            CompletableFuture<EventSubscriptionList> result = CompletableFuture.completedFuture(new EventSubscriptionList());
            final Iterator<BlockInfo.TransactionEnvelopeInfo> txIterator = TxUtils.getBlockTransactions(blockData.blockInfo);

            while (txIterator.hasNext()) {
                final BlockInfo.TransactionEnvelopeInfo transactionEnvelopeInfo = txIterator.next();
                final List<ChaincodeEvent> transactionEvents = TxUtils.getTransactionEvents(transactionEnvelopeInfo);

                final String transactionID = transactionEnvelopeInfo.getTransactionID();

                if (!transactionEnvelopeInfo.isValid())
                    continue;

                for (ListIterator<ChaincodeEvent> iterator = transactionEvents.listIterator(); iterator.hasNext(); ) {
                    final int eventIndex = iterator.nextIndex();
                    final ChaincodeEvent chaincodeEvent = iterator.next();

                    for (EventListenerInfo e : eventsWaiting) {
                        final String chaincodeId = chaincodeEvent.getChaincodeId();
                        final String eventName = chaincodeEvent.getEventName();
                        if (e.chaincodePattern.matcher(chaincodeId).matches()
                                && e.eventNamePattern.matcher(eventName).matches()) {

                            CompletableFuture<Boolean> filter = e.listener.filter(chaincodeEvent);

                            if (filter == null) {
                                filter = CompletableFuture.completedFuture(Boolean.TRUE);
                            } else {
                                filter = filter.exceptionally((t) -> {
                                    logger.warn("Filtering failed on {}, exclude", chaincodeEvent, t);
                                    return Boolean.FALSE;
                                });
                            }

                            result = result.thenCombineAsync(filter, (subs, currRelate) -> {
                                if (Boolean.TRUE.equals(currRelate)) {
                                    boolean needsFetching = false;
                                    if (!Empty.class.isAssignableFrom(e.paramClass)
                                            && e.paramClass != Void.class) {
                                        needsFetching = blockData.blockInfo.isFiltered();
                                    }
                                    subs.needsFetching |= needsFetching;
                                    subs.subscriptions.add(new EventSubscription(e, transactionID, eventIndex, needsFetching));
                                }

                                return subs;
                            }, executorService);
                        }
                    }
                }
            }
            return result;
        }

        private void queryBlockEvents(CompletableFuture<Void> completableFuture,
                                      BlockData blockData) {
            for (Iterator<String> iterator = blockData.fetchQueue.iterator(); iterator.hasNext(); ) {
                String s = iterator.next();
                List<ChaincodeEvent> chaincodeEvents;
                try {
                    chaincodeEvents = FabricQueryException.withGuard(() -> TxUtils.queryEventsByTransactionID(channel, s));
                } catch (FabricQueryException e) {
                    // TODO
                    logger.warn("Exception while queriying data", e);
                    executorService.schedule(() -> queryBlockEvents(completableFuture, blockData),
                            errorBlockMillis, TimeUnit.MILLISECONDS);
                    return;
                } catch (Exception e) {
                    logger.warn("Ignore fetch error", e);
                    chaincodeEvents = null;
                }

                if (chaincodeEvents != null && !chaincodeEvents.isEmpty())
                    blockData.txList.put(s, chaincodeEvents);
                iterator.remove();
            }

            completableFuture.complete(null);
        }

        private CompletableFuture<Void> fetchTransactions(BlockData blockData) {
            blockData.eventSubscriptionList.subscriptions.forEach((e) -> {
                if (e.needFetching)
                    blockData.fetchQueue.add(e.transactionId);
            });

            final CompletableFuture<Void> completableFuture = new CompletableFuture<>();
            CompletableFuture.runAsync(() -> queryBlockEvents(completableFuture, blockData));
            return completableFuture;
        }

        private synchronized void processNextBlock() {
            final BlockData blockData = blockInfoMap.get(nextBlockNumber);

            if (blockData == null || blockData.blockInfo == null) {
                scheduleNextBlockFetching();
                return;
            }

            if (blockData.processing != null)
                return;

            blockData.processing =
                    // 1) filter subscriptions
                    filterSubscriptions(blockData)
                            .thenApplyAsync((eventSubscriptionList) -> {
                                blockData.eventSubscriptionList = eventSubscriptionList;
                                return null;
                            }, executorService)
                            // 2) fetch transactions if necessary
                            .thenComposeAsync((x) -> {
                                if (blockData.eventSubscriptionList.needsFetching)
                                    return fetchTransactions(blockData);
                                else
                                    return CompletableFuture.completedFuture(null);
                            }, executorService)
                            // 3) Run processing
                            .thenComposeAsync((x) -> {
                                return processBlock(blockData);
                            }, executorService)
                            // 4) Go to the next block
                            .handleAsync((r, t) -> {
                                blockCompleted(blockData.blockNumber);
                                return null;
                            }, executorService);
        }

        private void saveStartBlock(long blockNumber) {
            try {
                if (persister != null)
                    persister.setStartBlock(channelName, blockNumber);
            } catch (Exception e) {
                logger.warn("persisting block failed: {}", blockNumber);
            }
        }

        private synchronized void blockCompleted(long blockNumber) {

            if (blockNumber != nextBlockNumber)
                throw new InternalError(String.format("Invalid block number: %s, expect %s", blockNumber, nextBlockNumber));

            nextBlockNumber++;
            logger.debug("Advance to block {}", nextBlockNumber);

            saveStartBlock(nextBlockNumber);
            blockInfoMap.remove(nextBlockNumber - 1);

            processNextBlock();
        }

        private synchronized CompletableFuture<Void> processBlock(BlockData blockInfo) {
            final EventSubscriptionList eventSubscriptionList = blockInfo.eventSubscriptionList;
            final Map<String, List<ChaincodeEvent>> txList = blockInfo.txList;
            final long blockNumber = blockInfo.blockNumber;

            blockInfo.blockInfo.getEnvelopeInfos().forEach((e) -> {
                if (e.isValid() && e instanceof BlockInfo.TransactionEnvelopeInfo) {
                    final BlockInfo.TransactionEnvelopeInfo txEnvelopeInfo = (BlockInfo.TransactionEnvelopeInfo) e;
                    txList.computeIfAbsent(e.getTransactionID(),
                            (k) -> TxUtils.getTransactionEvents(txEnvelopeInfo));
                }
            });

            CompletableFuture<Void> blockProcessor;

            if (enableEventsDelivery != null) {
                if (!enableEventsDelivery.isDone())
                    logger.info("Events delivery is not enabled, postpone block processing");
                blockProcessor = enableEventsDelivery;
            } else
                blockProcessor = CompletableFuture.completedFuture(null);

            for (EventSubscription s : eventSubscriptionList.subscriptions) {

                final String transactionID = s.transactionId;
                final List<ChaincodeEvent> chaincodeEvents = txList.get(transactionID);

                final EventListenerInfo listenerInfo = s.listenerInfo.get();
                if (listenerInfo != null && s.eventIndex < chaincodeEvents.size()) {
                    final ChaincodeEvent chaincodeEvent = chaincodeEvents.get(s.eventIndex);
                    final String chaincodeId = chaincodeEvent.getChaincodeId();
                    final String eventName = chaincodeEvent.getEventName();

                    try {
                        final Method newBuilder = listenerInfo.paramClass.getMethod("newBuilder");
                        final Message.Builder builder = (Message.Builder) newBuilder.invoke(null);
                        final Message message;

                        if (Empty.class.isAssignableFrom(listenerInfo.paramClass))
                            message = Empty.getDefaultInstance();
                        else if (Void.class.isAssignableFrom(listenerInfo.paramClass))
                            message = null;
                        else
                            message = builder.mergeFrom(chaincodeEvent.getPayload()).build();

                        blockProcessor = blockProcessor
                                .thenCompose((r) -> {
                                    logger.info("Begin event handling(block={}, chaincode={}, name={}, data={}, txid={})", blockNumber, chaincodeId, eventName, message, transactionID);
                                    return listenerInfo.listener.onEvent(chaincodeEvent, message);
                                })
                                .handle((r, t) -> {
                                    if (t != null)
                                        logger.warn("Event handling failed(block={}, chaincode={}, name={}, data={}, txid={})", blockNumber, chaincodeId, eventName, message, transactionID, t);
                                    else
                                        logger.info("Event handling succeeded (block={}, chaincode={}, name={}, data={}, txid={}) -> ({})", blockNumber, chaincodeId, eventName, message, transactionID, r);
                                    return null;
                                });

                    } catch (Exception e) {
                        logger.warn("Prepare Event Handling failed(block={}, chaincode={}, name={}, txid={}): ", blockNumber, chaincodeId, eventName, transactionID, e);
                    }
                }
            }

            return blockProcessor;
        }

        private void fetchBlock(long blockNumber) throws FabricQueryException {

            final BlockData blockData;

            synchronized (this) {
                if (blockNumber != nextBlockNumber)
                    return;

                blockData = blockInfoMap.get(blockNumber);
                if (blockData != null && blockData.blockInfo != null)
                    return;
            }

            logger.info("Fetch block {}", blockNumber);
            final BlockInfo blockInfo = FabricQueryException.withGuard(() -> channel.queryBlockByNumber(blockNumber));
            addBlock(blockInfo);
        }

        private boolean filterTransactionEvents(List<ChaincodeEvent> transactionEvents, boolean isFilteredData) {
            boolean needFetching = false;

            for (Iterator<ChaincodeEvent> iterator = transactionEvents.iterator(); iterator.hasNext(); ) {
                ChaincodeEvent chaincodeEvent = iterator.next();
                for (EventListenerInfo e : eventsWaiting) {
                    final String chaincodeId = chaincodeEvent.getChaincodeId();
                    final String eventName = chaincodeEvent.getEventName();
                    if (e.chaincodePattern.matcher(chaincodeId).matches()
                            && e.eventNamePattern.matcher(eventName).matches()) {
                        if (!Empty.class.isAssignableFrom(e.paramClass)
                                && e.paramClass != Void.class) {
                            needFetching = isFilteredData;
                        }
                    } else {
                        iterator.remove();
                    }
                }
            }
            return needFetching;
        }
    }

    public OrderingEventTracker(Persister persister) {
        this.persister = persister;
    }

    @Override
    public void configureChannel(Channel channel) throws Exception {
        if (!channelStateMap.containsKey(channel)) {
            final ChannelTracker channelTracker = new ChannelTracker(channel);
            channelStateMap.put(channel, channelTracker);
        }
    }

    @Override
    public void connectChannel(Channel channel) throws Exception {
        channelStateMap.get(channel).connectChannel();
    }

    @Override
    public long getStartBlock(Channel channel) {
        return channelStateMap.get(channel).startBlock;
    }

    @Override
    public boolean useFilteredBlocks(Channel channel) {
        return true;
    }

    public <T extends Message> void addEventListener(String chaincodeName, String eventName, Class<T> parameterClass, EventListener<T> listener) {
        final EventListenerInfo eventListenerInfo = new EventListenerInfo(
                Pattern.compile(chaincodeName),
                Pattern.compile(eventName),
                parameterClass,
                listener);
        eventsWaiting.add(eventListenerInfo);
    }

    public synchronized void enableEventsDelivery() {
        if (enableEventsDelivery != null) {
            logger.info("Enable events delivery");
            enableEventsDelivery.complete(null);
            enableEventsDelivery = null;
        }
    }
}

